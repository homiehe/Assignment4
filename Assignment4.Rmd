---
title: "Assignment4"
author: "Hongyi He"
date: "2018年2月20日"
output: pdf_document
---
```{r}
library(tidyverse)
```

#####10.5 Exercises

##1. How can you tell if an object is a tibble? (Hint: try printing mtcars, which is a regular data frame).

```{r}
class(mtcars)
```
  So its a data frame.

##2. Compare and contrast the following operations on a data.frame and equivalent tibble. What is different? Why might the default data frame behaviours cause you frustration?

```{r}
df <- data.frame(abc = 1, xyz = "a")
df_tibble <- as.tibble(df)
```

```{r}
df$x
df_tibble$x
```
  
  tibble doesn't work here
  
```{r}
df[, "xyz"]
df_tibble[, "xyz"]
```
  
  data frame returns a factor
  tibble returns a dataframe
  
```{r}
df[, c("abc", "xyz")]
df_tibble[, c("abc", "xyz")]
```
  
  data frame returns a factor
  tibble returns a dataframe

## 3.If you have the name of a variable stored in an object, e.g. var <- "mpg", how can you extract the reference variable from a tibble?

```{r}
var <- "abc"

# Will extract the vector
df_tibble[[var]]
```

## 4.Practice referring to non-syntactic names in the following data frame by:

```{r}
annoying <- tibble(
  `1` = 1:10,
  `2` = `1` * 2 + rnorm(length(`1`))
)
```

      1).Extracting the variable called 1.
      
```{r}
annoying$`1`

```

      2).Plotting a scatterplot of 1 vs 2.
      
```{r}
ggplot(annoying, aes(x = `1`, y = `2`)) + geom_point()

```

      3).Creating a new column called 3 which is 2 divided by 1.

```{r}
annoying <-
  annoying %>%
  mutate(`3` = `2`/`1`)
```

      4).Renaming the columns to one, two and three.
  
```{r}
annoying %>%
  rename(one = `1`,
         two = `2`,
         three = `3`)
```

## 5.What does tibble::enframe() do? When might you use it?

```{r}
x <- c(1:10)
m <- enframe(x)
m
```

It turns a vector into a tibble.

## 6.What option controls how many additional column names are printed at the footer of a tibble?

```{r}
options(tibble.max_extra_cols = 5)
```


#####10.5 Exercises
```{r}
who <- read.csv("TB_burden_countries_2018-02-21.csv")

who1 <- who %>%
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases", na.rm = TRUE)
glimpse(who1)

who2 <- who1 %>%
 mutate(key = stringr::str_replace(key, "newrel", "new_rel"))

who3 <- who2 %>%
  separate(key, c("new", "type", "sexage"), sep = "_")

who4 <- who3 %>%
  select(-new, -iso2, -iso3)

who5 <- who4 %>%
  separate(sexage, c("sex", "age"), sep = 1)
```
## 1.In this case study I set na.rm = TRUE just to make it easier to check that we had the correct values. Is this reasonable? Think about how missing values are represented in this dataset. Are there implicit missing values? What’s the difference between an NA and zero?
```{r}
gather(who, new_sp_m014:newrel_f65, key = "key", value = "cases") %>%
  group_by(country, year)  %>%
  mutate(missing = is.na(cases)) %>%
  select(country, year, missing) %>%
  distinct() %>%
  group_by(country, year) %>%
  filter(n() > 1)
```

## 2.What happens if you neglect the mutate() step? (mutate(key = stringr::str_replace(key, "newrel", "new_rel"))

There gonna be a warning “too few values” when separating,sexage is messing
```{r}
who3a <- who1 %>%
  separate(key, c("new", "type", "sexage"), sep = "_")
```

## 3.I claimed that iso2 and iso3 were redundant with country. Confirm this claim.

```{r}
select(who3, country, iso2, iso3) %>%
  distinct() %>%
  group_by(country) %>%
  filter(n() > 1)
```

## 4.For each country, year, and sex compute the total number of cases of TB. Make an informative visualisation of the data.

```{r}
who5 %>%
  group_by(country, year, sex) %>%
  filter(year > 1995) %>%
  summarise(cases = sum(cases)) %>%
  unite(country_sex, country, sex, remove = FALSE) %>%
  ggplot(aes(x = year, y = cases, group = country_sex, colour = sex)) +
  geom_line()
```